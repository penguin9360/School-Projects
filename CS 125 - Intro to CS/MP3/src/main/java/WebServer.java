import java.security.InvalidParameterException;
import java.util.HashMap;
import java.util.Map;

import io.vertx.core.Vertx;
import io.vertx.core.http.HttpMethod;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.core.json.Json;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.BodyHandler;
import io.vertx.ext.web.handler.StaticHandler;

/**
 * A class that runs a small web server which enables the web interface to play ConnectN.
 *
 * @see <a href="https://cs125.cs.illinois.edu/MP/3/">MP3 Documentation</a>
 * @see <a href="http://vertx.io/docs/vertx-web/java/">Vert.x-Web Documentation</a>
 */
public class WebServer {
    /**
     * The port that our server listens on.
     */
    private static final int DEFAULT_SERVER_PORT = 8126;

    /** Track boards used by clients. */
    private static Map<Integer, ConnectN> boardMap = new HashMap<>();

    /**
     * Handle action generated by the frontend.
     *
     * @param routingContext the routing context to use when processing the request
     */
    @SuppressWarnings("checkstyle:methodlength")
    private static void handleAction(final RoutingContext routingContext) {

        /*
         * Routing table. There should be a less terrible way to do this, but in Java it gets
         * complicated quickly. This is sufficient for our purposes.
         */
        String action = routingContext.request().getParam("action");
        JsonObject actionContent = routingContext.getBodyAsJson();
        JsonObject returnContent = new JsonObject();
        boolean success = true;

        /*
         * Decode common arguments that accompany several requests.
         */
        Player player = null;
        if (actionContent.containsKey("player")) {
            player = Json.decodeValue(actionContent.getJsonObject("player").toBuffer(),
                    Player.class);
        }

        ConnectN board = null;
        if (actionContent.containsKey("board")) {
            board = boardMap.get(actionContent.getInteger("board"));
        }

        try {
            switch (action) {
                case "newBoard":
                    if (board != null) {
                        boardMap.remove(board.getID());
                    }
                    board = new ConnectN(actionContent.getInteger("width"),
                            actionContent.getInteger("height"),
                            actionContent.getInteger("n"));
                    boardMap.put(board.getID(), board);
                    break;
                case "newPlayer":
                    player = new Player(actionContent.getString("name"));
                    break;
                case "changePlayerName":
                    assert player != null;
                    player.setName(actionContent.getString("name"));
                    break;
                case "setBoardAt":
                    assert board != null;
                    if (actionContent.containsKey("y")) {
                        success = board.setBoardAt(player, actionContent.getInteger("x"),
                                actionContent.getInteger("y"));
                    } else {
                        success = board.setBoardAt(player, actionContent.getInteger("x"));
                    }
                    break;
                default:
                    throw new InvalidParameterException(action + " is not a valid action");
            }
        } catch (Exception e) {
            System.out.println("Something went wrong: " + e);
            success = false;
        }

        /*
         * Send transformed data back to the client as a JSON object.
         */
        returnContent.put("success", Json.encode(success));
        if (board != null) {
            returnContent.put("boardID", Json.encode(board.getID()));
            returnContent.put("winner", Json.encode(board.getWinner()));
            returnContent.put("board", Json.encode(board.getBoard()));
        }
        if (player != null) {
            returnContent.put("player", Json.encode(player));
        }
        routingContext.response()
                .putHeader("content-type", "application/json; charset=utf-8")
                .end(returnContent.encode());
    }

    /**
     * Start the transformation web server.
     * <p>
     * Note that the main method is not used during testing. So you are free to both understand and
     * modify this function.
     *
     * @param unused unused input arguments
     */
    public static void main(final String[] unused) {

        Vertx vertx = Vertx.vertx();

        /*
         * Set up routes to our static assets: index.html, index.js, and index.css. We use a single
         * route here for all GET requests. In a more complex web server this would probably not be
         * appropriate, but in this simple case it works fine.
         */
        Router router = Router.router(vertx);
        router.route().method(HttpMethod.GET).handler(StaticHandler.create());

        /*
         * The BodyHandler ensures that we can retrieve JSON data from our request body. We send all
         * POST requests to the handler defined above. Again, in a more complex server you would
         * want to do something more sophisticated.
         */
        router.route().method(HttpMethod.POST).handler(BodyHandler.create());
        router.route(HttpMethod.POST, "/:action").handler(WebServer::handleAction);

        /*
         * Turn on compression, although upstream compression isn't currently implemented.
         */
        HttpServerOptions serverOptions = new HttpServerOptions();
        serverOptions.setCompressionSupported(true);
        serverOptions.setDecompressionSupported(true);

        HttpServer server = vertx.createHttpServer();

        /*
         * Ensure that the server is closed when we exit, to avoid port collisions.
         */
        Runtime.getRuntime().addShutdownHook(new Thread(vertx::close));

        /*
         * Start the server.
         */
        System.out.println("Starting web server on localhost:" + DEFAULT_SERVER_PORT);
        System.out.println("If you get a message about an address already in use, please shut\n"
                + "down other running instances of this web server.");
        server.requestHandler(router::accept).listen(DEFAULT_SERVER_PORT);
    }
}
