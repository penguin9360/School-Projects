/*
 * Store our foreground image so that we can reset it as needed.
 */

var images = {};

/*
 * We maintain two canvases: the foreground canvas holds the foreground image,
 * the background canvas hold the background image. What is shown to the user is
 * always the merged canvas. This allows us to let the user download their
 * modified image while still only modifying the foreground content.
 */
var foregroundCanvas;
var backgroundCanvas;
var mergedCanvas;

$(function () {
  /*
   * Reject bad browsers immediately. Not every browser has the features that we
   * need, although today most do.
   */
  if (!checkBrowser()) {
    return;
  }

  /*
   * Setup our foreground and background canvas, and get a handle to the merged
   * canvas which is visible to the user.
   */
  mergedCanvas = $("#canvas").get(0);

  foregroundCanvas = document.createElement('canvas');
  foregroundCanvas.width = mergedCanvas.width;
  foregroundCanvas.height = mergedCanvas.height;
  backgroundCanvas = document.createElement('canvas');
  backgroundCanvas.width = mergedCanvas.width;
  backgroundCanvas.height = mergedCanvas.height;

  /*
   * Set up file input handlers. These listen for events generated by the file
   * input dialog box at the top of the display.
   */

  $("#input").change(function () {
    if (!checkBrowser()) {
      return;
    } else if (!this.files) {
      $("#badBrowserModal").modal('show');
      return;
    } else if (!this.files[0]) {
      $("#noFileModal").modal('show');
      return;
    }
    fileReaderFromFile(this.files[0]);
  });
  $("#input").click(function () {
    this.value = null;
  });

  /*
   * Set button handlers.
   */

  $("[data-action]").click(function () {
    // Click handlers for all image transformation functions
    transformCanvas($(this).data("action"), foregroundCanvas);
    $(this).tooltip('hide');
  });
  $(".background").click(function () {
    // Special handling for the background image
    imageFromSource($(this).data("background"), "background", backgroundCanvas);
    $(this).tooltip('hide');
  });
  $("#reset").click(function () {
    // Reset the foreground image to its original state
    canvasFromImage("foreground", foregroundCanvas);
    $(this).tooltip('hide');
  });
  $("#delete").click(function () {
    // Delete the foreground image and start over
    delete(images["foreground"]);
    canvasFromImage("foreground", foregroundCanvas);
    $(this).tooltip('hide');
  });
  disableOrEnableControls(false);

  /*
   * Enable tooltips to provide guidance for buttons and other controls.
   */
  $('[data-toggle="tooltip"]').tooltip()

});


/*
 * We use a similar pipeline for both foreground image changes that start with a
 * file and background image changes that start with a URL. This first function
 * only gets called for file inputs.
 */
var fileReaderFromFile = function (file) {
  console.log("fileReaderFromFile");
  if (!checkBrowser()) {
    return;
  }
  var fileReader = new FileReader()
  fileReader.onload = function() {
    imageFromSource(fileReader.result, "foreground", foregroundCanvas);
  }
  fileReader.onerror = function () {
    $("#noFileModal").modal('show');
  }
  fileReader.readAsDataURL(file);
}

/*
 * The second stage in the pipeline gets called for both file inputs (foreground
 * images) and for background image changes, which use an image URL.
 */
var imageFromSource = function (source, name, canvas) {
  console.log("imageFromSource");
  if (source === "") {
    delete(images[name]);
    canvasFromImage(name, canvas);
    return;
  }
  images[name] = new Image();
  images[name].onload = function () {
    canvasFromImage(name, canvas);
  }
  images[name].onerror = function () {
    delete(images[name]);
    $("#badImageModal").modal('show');
  }
  images[name].src = source;
}

/*
 * This is the third and last stage in the pipeline. At this point we have a
 * valid image object and all we need to do is load it on to the canvas. We
 * resize and center both foreground and background images, although all the
 * background images we provide are already appropriately sized for the canvas.
 */
var canvasFromImage = function (name, canvas) {
  console.log("canvasFromImage");

  disableOrEnableControls(typeof(images.foreground) !== "undefined");
  var image = images[name];

  if (!image) {
    var context = canvas.getContext("2d");
    context.clearRect(0, 0, canvas.width, canvas.height);
    mergeCanvases();
    return;
  }

  /*
   * Reject images that are empty in either dimension.
   */
  if (image.width === 0 || image.height === 0) {
    image = {};
    $("#badImageModal").modal('show');
    return;
  }

  /*
   * Initially fit the image to the canvas and center it.
   */
  var ratio = 1.;
  if (image.width > canvas.width || image.height > canvas.height) {
    var horizontalRatio = canvas.width / image.width;
    var verticalRatio =  canvas.height / image.height;
    ratio = Math.min(horizontalRatio, verticalRatio);
  }
  var scaledWidth = image.width * ratio;
  var scaledHeight = image.height * ratio;
  var shiftX = (canvas.width - scaledWidth) / 2;
  var shiftY = (canvas.height - scaledHeight) / 2;

  /*
   * Draw to the canvas.
   */

  var context = canvas.getContext("2d");
  context.clearRect(0, 0, canvas.width, canvas.height);
  context.drawImage(image, 0, 0, image.width, image.height,
    shiftX, shiftY, scaledWidth, scaledHeight);
  mergeCanvases();
}

/*
 * All transform functions that use the Java backend come here.
 */
var transformCanvas = function(transform, canvas) {
  console.log("transformCanvas:" + transform);

  /*
   * Grab current canvas data and serialize it to JSON for POST transfer.
   */
  var context = canvas.getContext("2d");
  var originalData = context.getImageData(0, 0, canvas.width, canvas.height);
  var postContents = {
    width: originalData.width,
    height: originalData.height,
    data: btoa(originalData.data.reduce((data, byte) => data + String.fromCharCode(byte), ''))
  }

  /*
   * Make the post call.
   */
  $.post(transform, JSON.stringify(postContents))
    .done(function (transformedContents) {
      /*
       * Grab the transformed data, write it to the foreground canvas, and
       * remerge the canvases so that it's visible.
       */
      var newData = new Uint8Array(atob(transformedContents.data)
        .split("").map(function(c) {
          return c.charCodeAt(0);
        }));
      var context = canvas.getContext("2d");
      var newImageData = context.createImageData(canvas.width, canvas.height);
      newImageData.data.set(newData);
      context.putImageData(newImageData, 0, 0);
      mergeCanvases();
    })
    .fail(function () {
      /*
       * Assume the server is dead if a failure occurs.
       */
      $("#deadServerModal").modal('show');
    });
}

/*
 * Helper function to turn controls on and off depending on whether we have a
 * foreground image loaded or not.
 */
var disableOrEnableControls = function (enable) {
  $(".action").attr("disabled", !enable);
  if (enable) {
    $("#instructions").css("visibility", "hidden");
  } else {
    $("#instructions").css("visibility", "visible");
  }
}

/*
 * Helper function to merge the contents of the foreground and background
 * canvsas. Called when either change.
 */
var mergeCanvases = function (element) {
  console.log("mergeCanvases");
  var context = mergedCanvas.getContext("2d");
  context.clearRect(0, 0, mergedCanvas.width, mergedCanvas.height);
  context.drawImage(backgroundCanvas, 0, 0);
  context.drawImage(foregroundCanvas, 0, 0);
}

/*
 * Check to see if the user's browser has the features that we need.
 */
var checkBrowser = function() {
  if (typeof window.FileReader !== 'function') {
    disableOrEnableControls(false);
    $("input#input").attr("disabled", true);
    $("#badBrowserModal").modal('show');
    return false;
  }
  return true;
}

// vim: ts=2:sw=2:et:ft=javascript
